<style>/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */
code[class*="language-"],
pre[class*="language-"] {
  color: black;
  background: none;
  text-shadow: 0 1px white;
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.5;
  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;
  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none; }

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
  text-shadow: none;
  background: #b3d4fc; }

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
  text-shadow: none;
  background: #b3d4fc; }

@media print {
  code[class*="language-"],
  pre[class*="language-"] {
    text-shadow: none; } }

/* Code blocks */
pre[class*="language-"] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto; }

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
  background: #f5f2f0; }

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal; }

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: slategray; }

.token.punctuation {
  color: #999; }

.namespace {
  opacity: .7; }

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: #905; }

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
  color: #690; }

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
  color: #a67f59;
  background: rgba(255, 255, 255, 0.5); }

.token.atrule,
.token.attr-value,
.token.keyword {
  color: #07a; }

.token.function {
  color: #DD4A68; }

.token.regex,
.token.important,
.token.variable {
  color: #e90; }

.token.important,
.token.bold {
  font-weight: bold; }

.token.italic {
  font-style: italic; }

.token.entity {
  cursor: help; }
</style><style>@charset "UTF-8";
/*	FONTS
------------------------*/
@import url(https://fonts.googleapis.com/css?family=Raleway:400,700);
/*	TYPOGRAPHY
–––––––––––––––––––––––––––*/
html, body {
  height: 100%; }

body {
  font-family: "Raleway", Arial, sans-serif;
  color: #555;
  font-size: 100%;
  line-height: 1.5;
  background-color: #f2f2f2;
  margin: 0;
  display: flex;
  flex-direction: column; }

/* ------ Normalize ----- */
*,
*:after,
*:before {
  box-sizing: border-box; }

body header *,
body footer * {
  display: inline-block;
  vertical-align: middle; }

a {
  cursor: pointer;
  text-decoration: none;
  color: darkblue; }
  a:hover {
    text-decoration: underline; }

li {
  list-style: none; }

h1,
h2,
h3,
h4,
h5,
h6 {
  margin-top: 0; }

.apidocs h2:nth-of-type(2) {
  display: none; }

p > code,
td > code {
  font-size: 1.2rem !important;
  padding: .2rem .3rem;
  vertical-align: top; }

table {
  border-collapse: collapse;
  border: 1px solid #333; }
  table th, table td {
    padding: 0 .5rem; }
  table thead th {
    text-align: left;
    border-bottom: 1px solid #333;
    border-left: 1px solid #333; }
  table tbody tr:nth-child(odd) {
    background: rgba(171, 189, 203, 0.3); }

pre {
  margin-bottom: 2rem !important; }

/* ----- Plugins ------ */
.gitter-chat-embed-action-bar-item {
  display: none; }

/*---- Hacks ------ */
.footer {
  display: none !important; }
</style><header class="header"><div class="header-wrap"><div class="header-left"><a class="logo-link" href="#portal"><span>uPort | Developers</span></a></div><div class="header-right"><nav class="nav"><ul class="nav-list"><li class="nav-item"><a class="nav-link" href="#guides"><span>Guides</span></a></li><li class="nav-item"><a class="nav-link" href="#apidocs"><span>API Docs</span></a></li><li class="nav-item"><a class="nav-link" href="#tools"><span>Tools</span></a></li><li class="nav-item"><a class="nav-link" href="#gitter"><span>Gitter</span></a></li><li class="nav-item"><a class="nav-link" href="https://github.com/uport-project" target="_blank"><span>Github</span></a></li></ul></nav><div class="user-area"><a class="sign-in-link" href="#"><span>Sign In</span></a><div class="user"><img class="user-pic" src="#"/><div class="user-menu"><ul><li class="user"><b class="user-name">Jeff Scott Ward</b><span class="user-addr">0x9239812437981247</span></li><li class="log-out"><a href="#">Log Out</a></li></ul></div></div></div></div></div></header><style>.header,
.footer {
  position: relative;
  display: flex;
  flex-direction: column;
  border-bottom: 1px solid #333;
  justify-content: center;
  padding: 10px 2rem 10px;
  font-size: .8rem; }
  .header *,
  .footer * {
    margin: 0;
    padding: 0; }
  .header .header-wrap,
  .header .header-left,
  .header .header-right,
  .header .footer-wrap,
  .header .footer-left,
  .header .footer-right,
  .footer .header-wrap,
  .footer .header-left,
  .footer .header-right,
  .footer .footer-wrap,
  .footer .footer-left,
  .footer .footer-right {
    display: flex;
    flex-direction: row; }
  .header .header-right,
  .header .footer-right,
  .header .nav,
  .footer .header-right,
  .footer .footer-right,
  .footer .nav {
    flex: 1; }
  .header .logo-link,
  .footer .logo-link {
    padding-right: 2rem; }
  .header .nav-item,
  .footer .nav-item {
    padding: 0 1rem; }
  .header .logo-link,
  .header .nav-list li a,
  .header .sign-in-link,
  .header .legal-area a,
  .footer .logo-link,
  .footer .nav-list li a,
  .footer .sign-in-link,
  .footer .legal-area a {
    display: flex;
    flex-direction: column;
    justify-content: center; }
  .header .user-area,
  .footer .user-area {
    display: none; }
  .header .user-area .user,
  .header .legal-area .user,
  .footer .user-area .user,
  .footer .legal-area .user {
    display: none; }
    .header .user-area .user .user-pic,
    .header .legal-area .user .user-pic,
    .footer .user-area .user .user-pic,
    .footer .legal-area .user .user-pic {
      width: 25px;
      height: 25px;
      background: gray;
      border-radius: 50%; }
    .header .user-area .user .user-menu,
    .header .legal-area .user .user-menu,
    .footer .user-area .user .user-menu,
    .footer .legal-area .user .user-menu {
      position: absolute;
      min-width: 150px;
      top: 100%;
      right: 2rem;
      background: lightblue;
      border: 1px solid darkblue; }
      .header .user-area .user .user-menu ul, .header .user-area .user .user-menu li,
      .header .user-area .user .user-menu .user-name,
      .header .user-area .user .user-menu .user-addr,
      .header .legal-area .user .user-menu ul,
      .header .legal-area .user .user-menu li,
      .header .legal-area .user .user-menu .user-name,
      .header .legal-area .user .user-menu .user-addr,
      .footer .user-area .user .user-menu ul,
      .footer .user-area .user .user-menu li,
      .footer .user-area .user .user-menu .user-name,
      .footer .user-area .user .user-menu .user-addr,
      .footer .legal-area .user .user-menu ul,
      .footer .legal-area .user .user-menu li,
      .footer .legal-area .user .user-menu .user-name,
      .footer .legal-area .user .user-menu .user-addr {
        display: block; }
      .header .user-area .user .user-menu li,
      .header .legal-area .user .user-menu li,
      .footer .user-area .user .user-menu li,
      .footer .legal-area .user .user-menu li {
        padding: 10px; }
        .header .user-area .user .user-menu li:first-child,
        .header .legal-area .user .user-menu li:first-child,
        .footer .user-area .user .user-menu li:first-child,
        .footer .legal-area .user .user-menu li:first-child {
          border-bottom: 1px solid darkblue; }
  .header .user-area.menu-open .sign-in-link,
  .header .legal-area.menu-open .sign-in-link,
  .footer .user-area.menu-open .sign-in-link,
  .footer .legal-area.menu-open .sign-in-link {
    display: none; }
  .header .user-area.menu-open .user,
  .header .legal-area.menu-open .user,
  .footer .user-area.menu-open .user,
  .footer .legal-area.menu-open .user {
    display: block; }
  .header .legal-area,
  .footer .legal-area {
    display: flex; }
    .header .legal-area a,
    .footer .legal-area a {
      margin-left: 2rem; }
</style><!-- default to .main.______ page--><main class="main portal"><div class="portal"><div class="banner"><div class="banner-text"><h1>uPort Documentation</h1><p class="text-block">uPort is an open source software project to establish a global, unified, sovereign identity system for people, businesses, organizations, devices, and bots.</p></div><div class="banner-steps"><ul><li class="alpha"><div class="number"><span class="number-text">1</span></div><img class="step-img" src="#"/><div class="step-desc">Download the Mobile Wallet</div></li><li class="beta"><div class="number"><span class="number-text">2</span></div><img class="step-img" src="#"/><div class="step-desc">Register Your App</div></li><li class="omega"><div class="number"><span class="number-text">3</span></div><img class="step-img" src="#"/><div class="step-desc">Install the Libraries / SDK's</div></li></ul></div></div><div class="content-shortcuts"><ul><li class="guides"><div class="shortcut-wrap"><img src="#"/><label>Guides</label></div><div class="list-wrap"><ul><li><a href="#"><span>Getting Started</span></a></li><li><a href="#"><span>Requesting Credentials</span></a></li><li><a href="#"><span>Attesting Credentials</span></a></li><li><a href="#"><span>Signing Transactions</span></a></li></ul></div></li><li class="api-docs"><div class="shortcut-wrap"><img src="#"/><label>API Docs</label></div><div class="list-wrap"><ul><li><a href="#"><span>uport-connect</span></a></li><li><a href="#"><span>uport-js</span></a></li><li><a href="#"><span>uport-lite</span></a></li><li><a href="#"><span>uport-registry</span></a></li></ul></div></li><li class="tools"><div class="shortcut-wrap"><img src="#"/><label>Tools</label></div><div class="list-wrap"><ul><li><a href="http://truffleframework.com"><span>Truffle</span></a></li><li><a href="http://metamask.io"><span>MetaMask</span></a></li><li><a href="https://remix.ethereum.org/#version=soljson-v0.4.13+commit.fb4cb1a.js"><span>Remix</span></a></li><li><a href="https://github.com/ethereum/mist/releases"><span>Mist</span></a></li></ul></div></li></ul></div></div><style>.portal {
  text-align: center; }
  .portal .banner,
  .portal .content-shortcuts,
  .portal .whitepaper {
    padding: 3rem 5rem; }
  .portal .banner, .portal .whitepaper {
    background: purple;
    color: white; }
  .portal .text-block {
    max-width: 600px;
    margin: 0 auto 3em auto; }
  .portal .banner-steps ul {
    display: flex;
    justify-content: center; }
  .portal .banner-steps li {
    width: 20%;
    margin: 3rem; }
    .portal .banner-steps li .number {
      position: relative;
      border-radius: 50%;
      border: 1px solid #CCC;
      width: 30px;
      height: 30px;
      text-align: center;
      margin: 0 auto 1rem auto; }
      .portal .banner-steps li .number .number-text {
        position: relative;
        top: 5px; }
    .portal .banner-steps li .step-img {
      margin: 0 auto 1rem auto; }
  .portal .content-shortcuts {
    text-align: left; }
    .portal .content-shortcuts img, .portal .content-shortcuts label {
      display: block; }
    .portal .content-shortcuts label {
      border-bottom: 3px solid #CCC; }
    .portal .content-shortcuts ul, .portal .content-shortcuts li {
      margin: 0;
      padding: 0; }
    .portal .content-shortcuts > ul {
      display: flex;
      justify-content: center; }
      .portal .content-shortcuts > ul > li {
        flex: 1;
        margin: 0 1rem; }
    .portal .content-shortcuts .shortcut-wrap {
      text-align: center; }
    .portal .content-shortcuts .list-wrap li {
      border-bottom: 1px solid #AAA;
      padding: 1rem 0; }
</style><div class="guides"><div class="pagewrap"><div class="sidebar"></div><div class="content"><div class="guide"><section><h1>Getting Started</h1>
<p>Welcome to the uPort usage guide!</p>
<p>Here we will walk you through all the necessary steps to get up and running with your first dapp.</p>
<p>Web 3.0 and decentralized applications <em>require a fundamental rethinking</em> of the moving parts of the web so it is important to read everything or you may miss some important elements around the design decisions of what you are working with.</p>
<p><strong>Also please note</strong>: these libraries are in progress and are subject to change. Gitter is a great place for the community to congregate and help each other. Lets get started.</p>
<h2>Download the Mobile App</h2>
<p>Firstly, we will download the uPort mobile app.</p>
<p>The mobile app is where your <a href="https://blog.cloudflare.com/ecdsa-the-digital-signature-algorithm-of-a-better-internet/">ECDSA private keys</a> are held (inside the secure enclave that's unlocked with your fingerprint). These keys are what controls the administrative layer between your device and the blockchain.</p>
<p>You will also have locally stored data in the app that is relevant to you such as your contacts and verified credentials. Essentially, the phone is an extension of you, and uPort is your internet native passport to the secure, decentralized web.</p>
<p>You can download the mobile app with one of the links below.</p>
<p><a href="http://itunes.apple.com">uPort iOS</a> | <a href="http://play.google.com">uPort iOS</a></p>
<p>Once you have downloaded the app, go ahead and create an identity. This identity will be resident on the <code>RINKEBY</code> Ethereum test network. You can create more identities on the same netowrk or on other Ethereum networks (<code>ROPSTEN</code> and <code>KOVAN</code>) in the settings menu so you can test counterparty interactions on the <strong>same network</strong>.</p>
<h2>Register your App</h2>
<p>Next we shall regsiter an application on the blockchain.</p>
<p>When a users interacts with an app, they will desire to see relevant information, a picture, and any other helpful indicators on their transacation cards that this is the correct endpoint they wish to interact with. This registration process will create an identity for your app so that this becomes possible, and for your frontend to know where to listen to changes on the blockchain.</p>
<p>Let's go create an app over at the <a href="appmanager.uport.me">uPort App Manager</a>.</p>
<p><strong>Make sure to save the signing key somewhere secure! This will not be stored in browser for you for security reasons</strong>.</p>
<h2>Install the Library/SDK</h2>
<p>We now have the mobile uPort app and a registered application. Let's install the library in our project.</p>
<p><strong>Please make sure you have Node.Js and NPM installed</strong></p>
<p>uPort and its depending libraries are dependent on the Node.Js ecosystem.</p>
<p><em>Native (iOS &amp; Android) Application libraries are in the works.</em></p>
<p>Go to your Terminal and <code>cd</code> to your project folder.</p>
<pre><code class="language-bash">npm install --save uport-connect
</code></pre>
<h2>Add your Keys</h2>
<p>Now that we have the needed dependency, lets go grab our keys from the app manager.</p>
<p><strong>You may copy the code with the injected keys in the accordion at the bottom of your created app's page to help you get started quickly or you can follow the directions below.</strong></p>
<p>We need to instantiate the uPort object with an app's identity.</p>
<p>Lets create an object from the <code>Connect</code> function and feed in the App's name, id, and signing key.</p>
<pre><code class="language-js">const uport = new Connect('NAME_OF_DAPP', {
  clientId: 'CLIENT_ID',
  signer: SimpleSigner('SIGNING KEY')
})
</code></pre>
<p>The clientID is the public address of your app and the signer (wrapped with the SimpleSigner function) is the signing key of your app that you will help create JWT tokens. These bits of information are given to you after registering an application.</p>
<p><strong>We should also export the <code>web3</code> object from the resulting uport object for signing transactions later.</strong></p>
<pre><code class="language-js">const web3 = uport.getWeb3()
export { web3, uport }
</code></pre>
</section><section><h1>Requesting Credentials</h1>
<p>The first and most basic step you should take is to allow your user to connect their uPort to your app. The <code>requestCredentials</code> method is how you accomplish this, similar in concept to logging in , except there is no server session for you to manage. All you need to do to &quot;connect&quot; is to disclose the requested credentials you have in your uPort identity.</p>
<h2>Calling the request method</h2>
<p><strong>By default</strong> the <code>uport-connect</code> library will fire a QR image inside of an injected global modal to help you get up and running quickly.</p>
<p><strong>This can be disabled</strong> by intercepting the URI so you may use another library to customize the look and feel of the QR image. See <a href="#custom-qr-styling">Custom QR Styling</a></p>
<p>Once the user has scanned the displayed QR image, and has submitted their credentials, the promise should resolve with a Schema.org person JSON data payload. You can then handle this data however you desire in the then function.</p>
<pre><code class="language-js">// Basic usage with modal injection
uport.requestCredentials()
     .then((credentials) =&gt; {
       // Do something after they have disclosed credentials
})
</code></pre>
<p>The expected payload should look like:</p>
<pre><code class="language-js">{
  &quot;@context&quot;:&quot;http://schema.org&quot;,
  &quot;@type&quot;:&quot;Person&quot;,
  &quot;name&quot;:&quot;Agent Smith&quot;,
  &quot;address&quot;:&quot;23fga3r2hh87ddhq98dhas8dh101j9f449w0&quot;,
  &quot;network&quot;:&quot;ropsten&quot;,
  &quot;publicKey&quot;:&quot;0x04016751595cf2f1429367d6c83a826526g613b4f7574af55ded0364f0fb34600bceba9211e5864ae616d7e83b5e3c79f1c913b40c8d38c64952fef383fd3ad637&quot;,
  &quot;image&quot;:{
    &quot;@type&quot;:&quot;ImageObject&quot;,
    &quot;name&quot;:&quot;avatar&quot;,
    &quot;contentUrl&quot;:&quot;/ipfs/QmeXP3C3S95zV9Wj9e2VTq9Z3CCCNoqksJrM5VQYJx2yM9&quot;
  }
}
</code></pre>
<h2>Requesting specific credentials</h2>
<p>You can request specific credentials by submitting an array of values in an array of the <code>requested</code> key of a passed object.</p>
<pre><code class="language-js">uport.requestCredentials({
  requested: ['name', 'phone', 'country'],
  }).then((credentials) =&gt; {
    // Do something after they have disclosed credentials
})
</code></pre>
<h2>Enabling Push Notifications</h2>
<p>When a transaction is going to be signed, if the <code>notifications</code> flag is set to <code>true</code> <strong>it will allow any future transaction signing to fire a prompt in the uPort mobile app.</strong> For UX considerations, we encourage developers to use this, otherwise your users will have to scan a QR code per each interaction.</p>
<pre><code class="language-js">uport.requestCredentials({
  requested: ['name', 'phone', 'country'],
  notifcations: true
  }).then((credentials) =&gt; {
    // Do something after they have disclosed credentials
})
</code></pre>
<h2>Custom QR Styling (web)</h2>
<p>We have had success with the <a href="https://larsjung.de/kjua/">KJUA QR Library</a>. It's also recommended you wrap the QR or create a seperate button for mobile.</p>
<pre><code class="language-js">uport.requestCredentials({
  requested: ['name', 'phone', 'country'],
  notifcations: true,
  (uri) =&gt; {

    const qr = kjua({
      text: uri,
      fill: '#000000',
      size: 400,
      back: 'rgba(255,255,255,1)'
    })

    // Create wrapping link for mobile touch
    let aTag = document.createElement('a')
    aTag.href = uri

    // Nest QR in &lt;a&gt; and inject
    aTag.appendChild(qr)
    document.querySelector('#kqr').appendChild(aTag)
  }
  }).then((credentials) =&gt; {
    // Do something after they have disclosed credentials
})
</code></pre>
<h2>Logging in via Mobile (sdk)</h2>
<p><strong>Under construction</strong></p>
<h2>Playground</h2>
<iframe style="width:100%; max-width:95%; height: 800px;" src="https://www.webpackbin.com/bins/-Kq-LKec34MlPK9_UMVr"></iframe></section><section><h1>Attesting Credentials</h1>
<p>One of the core needs of Web 3.0 is to build trust in a self-sovereign world. We establish facts which are not mathematically derived by social consensus. To create social consensus, actors must attest to things being true. We can do this with uPort using the <code>uport.attestCredentials</code> function.</p>
<p><strong>NOTE:</strong> Currently only one credential can be pushed at a time. We are working to fix this soon.</p>
<h2>Calling the attest method</h2>
<pre><code class="language-js">uport.attestCredentials({
  sub: 'THE_RECEIVING_UPORT_ID',
  claim: { CUSTOM_PROPERTY: PROPERTY_VALUE },
})
</code></pre>
<h2>Setting an expiration date</h2>
<p>We can also optionally add an expiration date.</p>
<pre><code class="language-js">uport.attestCredentials({
  sub: 'THE_RECEIVING_UPORT_ID',
  claim: { CUSTOM_PROPERTY: PROPERTY_VALUE },
  exp: new Date().getTime() + 30 * 24 * 60 * 60 * 1000,  // Optional expiration
})
</code></pre>
<h2>Attesting multiple credentials</h2>
<p><strong>Under construction</strong></p>
</section><section><h1>Signing Transactions</h1>
<p>uPort comes pre-baked with a web3 instance that calls to <a href="https://github.com/ethereumjs/testrpc">Infura</a>, our p2p swarm of nodes we have built so you don't need to stand up your own. All you need to do is grab our <code>web3</code> object and instantiate a smart contract javascript object with a <strong>provided ABI</strong>.</p>
<h2>Supply the contract ABI</h2>
<p>An ABI (Application BINARY Interface) can be generated by compiling your smart contract with the <a href="https://ethereum.github.io/browser-solidity/">Remix</a> Web IDE. Its on the &quot;Contracts&quot; tab down where it says <code>interface</code>. You can deploy this contract to the chain with the <strong>Web3</strong> deploy code just below that in your local Ethereum node console or with our build &amp; deploy tool called <a href="http://truffleframework.com/">Truffle</a>.</p>
<pre><code class="language-js">function MyContractSetup () {
  let MyContractABI = web3.eth.contract(PROVIDED_CONTRACT_ABI)
  let MyContractObj = MyContractABI.at(DEPLOYED_CONTRACT_ADDRESS_LOCATION)
  return MyContractObj
}
const MyContract = MyContractSetup()
</code></pre>
<h2>Create the contract object</h2>
<p>In a typical application, upon load, there is data usually being requested by a server to get the current state of the user's data. We must do the same here, but rather than reading a SQL database, we are instead reading the blockchain.</p>
<p>At ConsenSys we use our Web 3.0 infrastructure stack called <a href="https://github.com/uport-project/demo/blob/master/infura.io">Infura</a> to make the amount of possible calls scalable. You could otherwise have an Ethereum node local on your machine with a downloaded copy of the blockchain you could query. Calls can be simulated without having a copy of the blockchain though using a local <a href="https://github.com/ethereumjs/testrpc">TestRPC</a> node, but thats out of scope for this guide.</p>
<pre><code class="language-js">// Basic call to get some return data, no transaction signing
MyContract.someMethod.call(METHOD_INPUT_DATA, (error, response) =&gt; {
  if (error) { throw error }
  console.log(response)
})
</code></pre>
<h2>Call a method on the contract</h2>
<p>Calling a method on a smart contract is essentially no different than that of a javascript function, except that solidity contracts cannot handle JSON objects, only strings and numbers.</p>
<pre><code class="language-js">// Transaction signing (that will fire a QR to scan or card in the mobile app)
MyContract.someMethod(METHOD_INPUT_DATA, (error, txHash) =&gt; {
  if (error) { throw error }
    waitForMined(txHash, { blockNumber: null }, // see next area
    function pendingCB () {
      // Signal to the user you're still waiting
      // for a block confirmation
    },
    function successCB (data) {
      // Great Success!
      // Likely you'll call some eventPublisherMethod(txHash, data)
    }
  )
})
</code></pre>
<h2>Wait for mining to complete</h2>
<p>When a transaction is signed and submitted to a smart contract, the Ethereum network takes time to mine (confirm) the transaction (typically 15 seconds). During this time we will need to poll the Web3 node (aka provider and in our case, its Infura), to see if its been mined. We will keep checking it with a function called <code>waitForMined</code> and have a pending callback and a success callback to manage state.</p>
<pre><code class="language-js">// Callback handler for whether it was mined or not
const waitForMined = (txHash, response, pendingCB, successCB) =&gt; {
  if (response.blockNumber) {
    successCB()
  } else {
    pendingCB()
      pollingLoop(txHash, response, pendingCB, successCB)
  }
}

// Recursive polling to do continuous checks for when the transaction was mined
const pollingLoop = (txHash, response, pendingCB, successCB) =&gt; {
  setTimeout(function () {
    web3.eth.getTransaction(txHash, (error, response) =&gt; {
      if (error) { throw error }
        if (response === null) {
          response = { blockNumber: null }
        } // Some ETH nodes do not return pending tx
        waitForMined(txHash, response, pendingCB, successCB)
    })
  }, 1000) // check again in one sec.
}
</code></pre>
</section></div></div></div><style>.guide {
  background: white;
  padding: 1rem; }
  .guide section {
    border-bottom: 1px solid #333; }
    .guide section > a {
      display: block; }
    .guide section:nth-child(2) h1, .guide section:nth-child(2) ~ h1 {
      margin-top: 2rem; }
  .guide h1 {
    font-size: 2rem;
    margin-bottom: 1.5rem; }
  .guide h1 ~ *:not(h1) {
    margin-left: 2rem; }
  .guide h2 {
    padding-top: 2rem;
    border-top: 1px solid #333; }
  .guide p {
    font-size: 1rem; }
</style></div><div class="apidocs"><div class="pagewrap"><div class="sidebar"></div><div class="content"><div class="lib" id="uport-connect"><section><h1 class="lib-header">uport-connect</h1><div class="lib-doc"><h2>Classes</h2>
<dl>
<dt><a href="#Connect">Connect</a> ⇐ <code><a href="#ConnectCore">ConnectCore</a></code></dt>
<dd><p>Primary object for frontend interactions with uPort. Bundles all neccesary functionality.</p>
</dd>
<dt><a href="#ConnectCore">ConnectCore</a></dt>
<dd><p>Primary object for frontend interactions with uPort. ConnectCore excludes
 some functionality found in Connect for a more customizable and lightweight integration.
 It does not provide any web3 functionality althought you can still use getProvider
 to get a provider to use with web3 or other libraries. It removes all default
 QR injection functionality. Your can choose how you want to handle the UX and/or
 QR generation and use any QR library you choose. For example, if used in a
 mobile native app QR generation is not even necessary.</p>
</dd>
</dl>
<p><a name="Connect"></a></p>
<h2>Connect ⇐ <a href="#ConnectCore"><code>ConnectCore</code></a></h2>
<p>Primary object for frontend interactions with uPort. Bundles all neccesary functionality.</p>
<p><strong>Kind</strong>: global class<br>
<strong>Extends</strong>: <a href="#ConnectCore"><code>ConnectCore</code></a></p>
<ul>
<li><a href="#Connect">Connect</a> ⇐ <a href="#ConnectCore"><code>ConnectCore</code></a>
<ul>
<li><a href="#new_Connect_new">new Connect(appName, [opts])</a></li>
<li><a href="#Connect+getWeb3">.getWeb3()</a> ⇒ <code>web3</code></li>
<li><a href="#ConnectCore+getProvider">.getProvider()</a> ⇒ <code>UportSubprovider</code></li>
<li><a href="#ConnectCore+requestCredentials">.requestCredentials([request], [uriHandler])</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+requestAddress">.requestAddress([uriHandler])</a> ⇒ <code>Promise.&lt;String, Error&gt;</code></li>
<li><a href="#ConnectCore+attestCredentials">.attestCredentials(credential, [uriHandler])</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+request">.request(request)</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+contract">.contract(abi)</a> ⇒ <code>Object</code></li>
<li><a href="#ConnectCore+sendTransaction">.sendTransaction(txobj)</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+addAppParameters">.addAppParameters(txobj, callbackUrl)</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
</ul>
</li>
</ul>
<hr>
<p><a name="new_Connect_new"></a></p>
<h3>new Connect(appName, [opts])</h3>
<p>Instantiates a new uPort connect object.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>appName</td><td><code>String</code></td><td></td><td><p>the name of your app</p>
</td>
    </tr><tr>
    <td>[opts]</td><td><code>Object</code></td><td></td><td><p>optional parameters</p>
</td>
    </tr><tr>
    <td>opts.credentials</td><td><code>Object</code></td><td></td><td><p>pre-configured Credentials object from <a href="http://github.com/uport-project/uport-js">http://github.com/uport-project/uport-js</a> object. Configure this if you need to create signed requests</p>
</td>
    </tr><tr>
    <td>opts.signer</td><td><code>function</code></td><td></td><td><p>signing function which will be used to sign JWT&#39;s in the credentials object</p>
</td>
    </tr><tr>
    <td>opts.clientId</td><td><code>String</code></td><td></td><td><p>uport identifier for your application this will be used in the default credentials object</p>
</td>
    </tr><tr>
    <td>[opts.network]</td><td><code>Object</code></td><td><code>&#x27;kovan&#x27;</code></td><td><p>network config object or string name, ie. { id: &#39;0x1&#39;, registry: &#39;0xab5c8051b9a1df1aab0149f8b0630848b7ecabf6&#39;, rpcUrl: &#39;<a href="https://mainnet.infura.io">https://mainnet.infura.io</a>&#39; } or &#39;kovan&#39;, &#39;mainnet&#39;, &#39;ropsten&#39;.</p>
</td>
    </tr><tr>
    <td>opts.rpcUrl</td><td><code>String</code></td><td></td><td><p>JSON rpc url (defaults to <a href="https://ropsten.infura.io">https://ropsten.infura.io</a>)</p>
</td>
    </tr><tr>
    <td>opts.infuraApiKey</td><td><code>String</code></td><td></td><td><p>Infura API Key (register here <a href="http://infura.io/register.html">http://infura.io/register.html</a>)</p>
</td>
    </tr><tr>
    <td>opts.topicFactory</td><td><code>function</code></td><td></td><td><p>function which generates topics and deals with requests and response</p>
</td>
    </tr><tr>
    <td>opts.uriHandler</td><td><code>function</code></td><td></td><td><p>default function to consume generated URIs for requests, can be used to display QR codes or other custom UX</p>
</td>
    </tr><tr>
    <td>opts.mobileUriHandler</td><td><code>function</code></td><td></td><td><p>default function to consume generated URIs for requests on mobile</p>
</td>
    </tr><tr>
    <td>opts.closeUriHandler</td><td><code>function</code></td><td></td><td><p>default function called after a request receives a response, can be to close QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">import { Connect } from 'uport-connect'
const uPort = new Connect('Mydapp')
</code></pre>
<hr>
<p><a name="Connect+getWeb3"></a></p>
<h3>connect.getWeb3() ⇒ <code>web3</code></h3>
<p>Instantiates and returns a web3 object wrapped with uPort functionality. For
more details see uportSubprovider and getProvider in connectCore.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>web3</code> - A uPort web3 object</p>
<hr>
<p><a name="ConnectCore+getProvider"></a></p>
<h3>connect.getProvider() ⇒ <code>UportSubprovider</code></h3>
<p>Instantiates and returns a web3 styple provider wrapped with uPort functionality.
For more details see uportSubprovider. uPort overrides eth_coinbase and eth_accounts
to start a get address flow or to return an already received address. It also
overrides eth_sendTransaction to start the send transaction flow to pass the
transaction to the uPort app.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>UportSubprovider</code> - A web3 style provider wrapped with uPort functionality</p>
<hr>
<p><a name="ConnectCore+requestCredentials"></a></p>
<h3>connect.requestCredentials([request], [uriHandler]) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Creates a request given a request object, will also always return the user's
uPort address. Calls given uriHandler with the uri. Returns a promise to
wait for the response.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - a promise which resolves with a response object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>[request]</td><td><code>Object</code></td><td><code>{}</code></td><td><p>request object</p>
</td>
    </tr><tr>
    <td>[uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const req = {requested: ['name', 'country']}
 connect.requestCredentials(req).then(credentials =&gt; {
     const address = credentials.address
     const name = credentials.name
     ...
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+requestAddress"></a></p>
<h3>connect.requestAddress([uriHandler]) ⇒ <code>Promise.&lt;String, Error&gt;</code></h3>
<p>Creates a request for only the address of the uPort identity. Calls given
uriHandler with the uri. Returns a promise to wait for the response.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;String, Error&gt;</code> - a promise which resolves with an address or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>[uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+attestCredentials"></a></p>
<h3>connect.attestCredentials(credential, [uriHandler]) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Consumes a credential object and generates a signed JWT. Creates a request
URI with the JWT. Calls given uriHandler with the URI. Returns a promise to wait
for the response. Throws error if no signer and/or app identifier is set.
Will not always receive a response, response is only a status.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - a promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>credential</td><td><code>Object</code></td><td></td><td><p>credential object</p>
</td>
    </tr><tr>
    <td>credential.sub</td><td><code>String</code></td><td></td><td><p>subject of this credential</p>
</td>
    </tr><tr>
    <td>credential.claim</td><td><code>Object</code></td><td></td><td><p>statement(s) which this credential claims, contructed as {key: &#39;value&#39;, ...}</p>
</td>
    </tr><tr>
    <td>credential.exp</td><td><code>String</code></td><td></td><td><p>expiry time of this credential</p>
</td>
    </tr><tr>
    <td>[uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const cred = {
   sub: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347'
   claim: {'email': 'hello@uport.me'}
   exp: '1300819380'
 }
 connect.attestCredentials(cred).then(res =&gt; {
   // response okay, received in uPort app
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+request"></a></p>
<h3>connect.request(request) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Create a request and returns a promise which resolves the response. This
function is primarly is used by more specified functions in this class, which
allow you to easily create the URIs and messaging server topics you need here.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - promise which resolves with a response object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>request</td><td><code>Object</code></td><td></td><td><p>request object</p>
</td>
    </tr><tr>
    <td>request.uri</td><td><code>String</code></td><td></td><td><p>uPort URI</p>
</td>
    </tr><tr>
    <td>request.topic</td><td><code>String</code></td><td></td><td><p>messaging server topic object</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td><code>String</code></td><td><code>this.uriHandler</code></td><td><p>function to consume URI, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+contract"></a></p>
<h3>connect.contract(abi) ⇒ <code>Object</code></h3>
<p>Builds and returns a contract object which can be used to interact with
a given contract. Similar to web3.eth.contract but with promises. Once specifying .at(address)
you can call the contract functions with this object. It will create a request,
call the uirHandler with the URI, and return a promise which resolves with
a transtaction ID.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Object</code> - contract object</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>abi</td><td><code>Object</code></td><td></td><td><p>contract ABI</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+sendTransaction"></a></p>
<h3>connect.sendTransaction(txobj) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Given a transaction object, similarly defined as the web3 transaction object,
it creates a URI which is passes to the uirHandler. It will create request
and returns a promise which resolves with the transaction id.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - A promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>txobj</td><td><code>Object</code></td><td></td><td><p>transaction object, can also be wrapped using addAppParameters</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const txobject = {
   to: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347',
   value: '0.1',
   function: setStatus(string 'hello', bytes32 '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347'),
   appName: 'MyDapp'
 }
 connect.sendTransaction(txobject).then(txID =&gt; {
   ...
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+addAppParameters"></a></p>
<h3>connect.addAppParameters(txobj, callbackUrl) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Adds application specific data to a transaction object. Then uses this data
when requests are created.</p>
<p><strong>Kind</strong>: instance method of <a href="#Connect"><code>Connect</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - A promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>txobj</td><td><code>Object</code></td><td><p>transaction object</p>
</td>
    </tr><tr>
    <td>callbackUrl</td><td><code>String</code></td><td><p>application callback url</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore"></a></p>
<h2>ConnectCore</h2>
<p>Primary object for frontend interactions with uPort. ConnectCore excludes
some functionality found in Connect for a more customizable and lightweight integration.
It does not provide any web3 functionality althought you can still use getProvider
to get a provider to use with web3 or other libraries. It removes all default
QR injection functionality. Your can choose how you want to handle the UX and/or
QR generation and use any QR library you choose. For example, if used in a
mobile native app QR generation is not even necessary.</p>
<p><strong>Kind</strong>: global class</p>
<ul>
<li><a href="#ConnectCore">ConnectCore</a>
<ul>
<li><a href="#new_ConnectCore_new">new ConnectCore(appName, [opts])</a></li>
<li><a href="#ConnectCore+getProvider">.getProvider()</a> ⇒ <code>UportSubprovider</code></li>
<li><a href="#ConnectCore+requestCredentials">.requestCredentials([request], [uriHandler])</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+requestAddress">.requestAddress([uriHandler])</a> ⇒ <code>Promise.&lt;String, Error&gt;</code></li>
<li><a href="#ConnectCore+attestCredentials">.attestCredentials(credential, [uriHandler])</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+request">.request(request)</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+contract">.contract(abi)</a> ⇒ <code>Object</code></li>
<li><a href="#ConnectCore+sendTransaction">.sendTransaction(txobj)</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
<li><a href="#ConnectCore+addAppParameters">.addAppParameters(txobj, callbackUrl)</a> ⇒ <code>Promise.&lt;Object, Error&gt;</code></li>
</ul>
</li>
</ul>
<hr>
<p><a name="new_ConnectCore_new"></a></p>
<h3>new ConnectCore(appName, [opts])</h3>
<p>Instantiates a new uPort connectCore object.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>appName</td><td><code>String</code></td><td></td><td><p>the name of your app</p>
</td>
    </tr><tr>
    <td>[opts]</td><td><code>Object</code></td><td></td><td><p>optional parameters</p>
</td>
    </tr><tr>
    <td>opts.credentials</td><td><code>Object</code></td><td></td><td><p>pre-configured Credentials object from <a href="http://github.com/uport-project/uport-js">http://github.com/uport-project/uport-js</a> object. Configure this if you need to create signed requests</p>
</td>
    </tr><tr>
    <td>opts.signer</td><td><code>function</code></td><td></td><td><p>signing function which will be used to sign JWT&#39;s in the credentials object</p>
</td>
    </tr><tr>
    <td>opts.clientId</td><td><code>String</code></td><td></td><td><p>uport identifier for your application this will be used in the default credentials object</p>
</td>
    </tr><tr>
    <td>[opts.network]</td><td><code>Object</code></td><td><code>&#x27;kovan&#x27;</code></td><td><p>network config object or string name, ie. { id: &#39;0x1&#39;, registry: &#39;0xab5c8051b9a1df1aab0149f8b0630848b7ecabf6&#39;, rpcUrl: &#39;<a href="https://mainnet.infura.io">https://mainnet.infura.io</a>&#39; } or &#39;kovan&#39;, &#39;mainnet&#39;, &#39;ropsten&#39;.</p>
</td>
    </tr><tr>
    <td>opts.infuraApiKey</td><td><code>String</code></td><td></td><td><p>Infura API Key (register here <a href="http://infura.io/register.html">http://infura.io/register.html</a>)</p>
</td>
    </tr><tr>
    <td>opts.topicFactory</td><td><code>function</code></td><td></td><td><p>function which generates topics and deals with requests and response</p>
</td>
    </tr><tr>
    <td>opts.uriHandler</td><td><code>function</code></td><td></td><td><p>default function to consume generated URIs for requests, can be used to display QR codes or other custom UX</p>
</td>
    </tr><tr>
    <td>opts.mobileUriHandler</td><td><code>function</code></td><td></td><td><p>default function to consume generated URIs for requests on mobile</p>
</td>
    </tr><tr>
    <td>opts.closeUriHandler</td><td><code>function</code></td><td></td><td><p>default function called after a request receives a response, can be to close QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">import { ConnectCore } from 'uport-connect'
const uPort = new ConnectCore('Mydapp')
</code></pre>
<hr>
<p><a name="ConnectCore+getProvider"></a></p>
<h3>connectCore.getProvider() ⇒ <code>UportSubprovider</code></h3>
<p>Instantiates and returns a web3 styple provider wrapped with uPort functionality.
For more details see uportSubprovider. uPort overrides eth_coinbase and eth_accounts
to start a get address flow or to return an already received address. It also
overrides eth_sendTransaction to start the send transaction flow to pass the
transaction to the uPort app.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>UportSubprovider</code> - A web3 style provider wrapped with uPort functionality</p>
<hr>
<p><a name="ConnectCore+requestCredentials"></a></p>
<h3>connectCore.requestCredentials([request], [uriHandler]) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Creates a request given a request object, will also always return the user's
uPort address. Calls given uriHandler with the uri. Returns a promise to
wait for the response.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - a promise which resolves with a response object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>[request]</td><td><code>Object</code></td><td><code>{}</code></td><td><p>request object</p>
</td>
    </tr><tr>
    <td>[uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const req = {requested: ['name', 'country']}
 connect.requestCredentials(req).then(credentials =&gt; {
     const address = credentials.address
     const name = credentials.name
     ...
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+requestAddress"></a></p>
<h3>connectCore.requestAddress([uriHandler]) ⇒ <code>Promise.&lt;String, Error&gt;</code></h3>
<p>Creates a request for only the address of the uPort identity. Calls given
uriHandler with the uri. Returns a promise to wait for the response.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;String, Error&gt;</code> - a promise which resolves with an address or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>[uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+attestCredentials"></a></p>
<h3>connectCore.attestCredentials(credential, [uriHandler]) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Consumes a credential object and generates a signed JWT. Creates a request
URI with the JWT. Calls given uriHandler with the URI. Returns a promise to wait
for the response. Throws error if no signer and/or app identifier is set.
Will not always receive a response, response is only a status.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - a promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>credential</td><td><code>Object</code></td><td></td><td><p>credential object</p>
</td>
    </tr><tr>
    <td>credential.sub</td><td><code>String</code></td><td></td><td><p>subject of this credential</p>
</td>
    </tr><tr>
    <td>credential.claim</td><td><code>Object</code></td><td></td><td><p>statement(s) which this credential claims, contructed as {key: &#39;value&#39;, ...}</p>
</td>
    </tr><tr>
    <td>credential.exp</td><td><code>String</code></td><td></td><td><p>expiry time of this credential</p>
</td>
    </tr><tr>
    <td>[uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const cred = {
   sub: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347'
   claim: {'email': 'hello@uport.me'}
   exp: '1300819380'
 }
 connect.attestCredentials(cred).then(res =&gt; {
   // response okay, received in uPort app
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+request"></a></p>
<h3>connectCore.request(request) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Create a request and returns a promise which resolves the response. This
function is primarly is used by more specified functions in this class, which
allow you to easily create the URIs and messaging server topics you need here.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - promise which resolves with a response object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>request</td><td><code>Object</code></td><td></td><td><p>request object</p>
</td>
    </tr><tr>
    <td>request.uri</td><td><code>String</code></td><td></td><td><p>uPort URI</p>
</td>
    </tr><tr>
    <td>request.topic</td><td><code>String</code></td><td></td><td><p>messaging server topic object</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td><code>String</code></td><td><code>this.uriHandler</code></td><td><p>function to consume URI, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+contract"></a></p>
<h3>connectCore.contract(abi) ⇒ <code>Object</code></h3>
<p>Builds and returns a contract object which can be used to interact with
a given contract. Similar to web3.eth.contract but with promises. Once specifying .at(address)
you can call the contract functions with this object. It will create a request,
call the uirHandler with the URI, and return a promise which resolves with
a transtaction ID.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Object</code> - contract object</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>abi</td><td><code>Object</code></td><td></td><td><p>contract ABI</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<hr>
<p><a name="ConnectCore+sendTransaction"></a></p>
<h3>connectCore.sendTransaction(txobj) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Given a transaction object, similarly defined as the web3 transaction object,
it creates a URI which is passes to the uirHandler. It will create request
and returns a promise which resolves with the transaction id.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - A promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Default</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>txobj</td><td><code>Object</code></td><td></td><td><p>transaction object, can also be wrapped using addAppParameters</p>
</td>
    </tr><tr>
    <td>[request.uriHandler]</td><td><code>function</code></td><td><code>this.uriHandler</code></td><td><p>function to consume uri, can be used to display QR codes or other custom UX</p>
</td>
    </tr>  </tbody>
</table>
<p><strong>Example</strong></p>
<pre><code class="language-js">const txobject = {
   to: '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347',
   value: '0.1',
   function: setStatus(string 'hello', bytes32 '0xc3245e75d3ecd1e81a9bfb6558b6dafe71e9f347'),
   appName: 'MyDapp'
 }
 connect.sendTransaction(txobject).then(txID =&gt; {
   ...
 })

 
</code></pre>
<hr>
<p><a name="ConnectCore+addAppParameters"></a></p>
<h3>connectCore.addAppParameters(txobj, callbackUrl) ⇒ <code>Promise.&lt;Object, Error&gt;</code></h3>
<p>Adds application specific data to a transaction object. Then uses this data
when requests are created.</p>
<p><strong>Kind</strong>: instance method of <a href="#ConnectCore"><code>ConnectCore</code></a><br>
<strong>Returns</strong>: <code>Promise.&lt;Object, Error&gt;</code> - A promise which resolves with a resonse object or rejects with an error.</p>
<table>
  <thead>
    <tr>
      <th>Param</th><th>Type</th><th>Description</th>
    </tr>
  </thead>
  <tbody>
<tr>
    <td>txobj</td><td><code>Object</code></td><td><p>transaction object</p>
</td>
    </tr><tr>
    <td>callbackUrl</td><td><code>String</code></td><td><p>application callback url</p>
</td>
    </tr>  </tbody>
</table>
<hr>
</div></section></div></div></div></div><style>.lib {
  background: white;
  padding: 1rem; }
  .lib .lib-doc {
    padding-left: 1rem; }
    .lib .lib-doc > ul {
      padding-left: 1rem; }
    .lib .lib-doc hr {
      margin: 3rem 0; }
    .lib .lib-doc p, .lib .lib-doc table, .lib .lib-doc pre {
      margin-left: 1rem; }
    .lib .lib-doc a code {
      font-size: 1.5rem; }
  .lib h1 {
    font-size: 2rem;
    margin-bottom: 0;
    text-decoration: underline; }
  .lib dl, .lib h2:first-child {
    display: none; }
  .lib p {
    font-size: 1rem; }
</style><div class="tools"><div class="pagewrap"><div class="sidebar"></div><div class="content"><ul><li><a href="http://truffleframework.com" target="_blank"><img src="/img/truffle-logo.svg"/><h3 class="title">Truffle</h3><p class="desc">Truffle is the most popular development framework for Ethereum with a mission to make your life a whole lot easier.</p></a></li><li><a href="http://metamask.io" target="_blank"><img src="/img/metamask-logo.png"/><h3 class="title">Metamask</h3><p class="desc">MetaMask is a bridge that allows you to visit the distributed web of tomorrow in your browser today. It allows you to run Ethereum dApps right in your browser without running a full Ethereum node.</p></a></li><li><a href="https://remix.ethereum.org/#version=soljson-v0.4.13+commit.fb4cb1a.js" target="_blank"><img src="/img/ethereum-logo.png"/><h3 class="title">Remix</h3><p class="desc">Remix is an IDE for the smart contract programming language Solidity and has an integrated debugger and testing environment.</p></a></li><li><a href="https://github.com/ethereum/mist/releases" target="_blank"><img src="/img/mist-logo.png"/><h3 class="title">Mist</h3><p class="desc">The Mist browser is a gateway to decentralized applications on the Ethereum blockchain. It allows you to hold and secure ether and other crypto-assets built on Ethereum, as well as write, deploy and use smart contracts.          </p></a></li></ul></div></div></div><style>.tools .content {
  display: flex;
  justify-content: center;
  align-items: center; }
  .tools .content ul {
    display: flex;
    flex-wrap: wrap; }
    .tools .content ul li {
      flex-basis: 50%;
      text-align: center;
      padding: 0;
      max-width: 22rem; }
      .tools .content ul li p {
        text-align: left; }
      .tools .content ul li a {
        padding: 1rem;
        display: block; }
        .tools .content ul li a img {
          max-width: 8rem;
          max-height: 8rem; }
        .tools .content ul li a:hover {
          text-decoration: none;
          background: #ccc;
          border-radius: .5rem; }
</style><div class="myapps"><div class="pagewrap"><div class="sidebar"><section><h2>My Apps</h2><ul><li><a href="#"><span>Application 1</span></a></li><li><a href="#"><span>Application 2</span></a></li><li><a href="#"><span>Application 3</span></a></li><li><a href="#"><span>Application 4</span></a></li><li><a href="#"><span>Application 5</span></a></li></ul></section></div></div></div><div class="gitter"><div class="pagewrap"><div class="sidebar"></div><div class="content"></div></div></div><style>.gitter .pagewrap .content {
  position: relative;
  padding: 0 !important; }
  .gitter .pagewrap .content iframe {
    width: 100%;
    height: 100%; }
</style></main><style>main {
  border-bottom: 1px solid #333;
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow-y: scroll; }
  main > * {
    display: none; }
  main.portal .portal {
    display: flex;
    flex-direction: column;
    flex: 1; }
  main.guides .guides {
    display: flex;
    flex-direction: column;
    flex: 1; }
  main.apidocs .apidocs {
    display: flex;
    flex-direction: column;
    flex: 1; }
  main.tools .tools {
    display: flex;
    flex-direction: column;
    flex: 1; }
  main.myapps .myapps {
    display: flex;
    flex-direction: column;
    flex: 1; }
  main.gitter .gitter {
    display: flex;
    flex-direction: column;
    flex: 1; }
  main .pagewrap {
    display: flex;
    height: 100%; }
    main .pagewrap .content {
      overflow-y: scroll;
      flex: 1; }
  main .sidebar {
    background: lightgray;
    padding: 1rem;
    width: 300px;
    overflow-y: scroll; }
    main .sidebar code {
      display: none; }
    main .sidebar ul, main .sidebar li {
      margin: 0;
      padding: 0; }
    main .sidebar ul {
      margin-bottom: 1rem; }
    main .sidebar li {
      padding-left: 1rem;
      font-size: .8rem; }
    main .sidebar h1 {
      font-size: 1rem;
      margin-bottom: .5rem; }
    main .sidebar span {
      font-size: .9rem; }
  main .content {
    padding: 1rem; }
    main .content p, main .content code, main .content textarea, main .content input {
      font-size: .8rem; }
</style><footer class="footer"><div class="footer-wrap"><div class="footer-left"><a class="logo-link" href="#"><div class="logo-group"><img class="logo-img" src="#"/><span>| Uport.me</span></div></a></div><div class="footer-right"><nav class="nav"><ul class="nav-list"><li class="nav-item"><a class="nav-link" href="https://github.com/uport-project" target="_blank"><span>D.I.F.</span></a></li><li class="nav-item"><a class="nav-link" href="#" target="_blank"><span>Github</span></a></li></ul></nav><div class="legal-area"><a class="tos" href="#"><span>Terms of Service</span></a><a class="privacy" href="#"><span>Privacy Policy</span></a></div></div></div></footer><script>
/* **********************************************
     Begin prism-core.js
********************************************** */

var _self = (typeof window !== 'undefined')
	? window   // if in browser
	: (
		(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)
		? self // if in worker
		: {}   // if in node js
	);

/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 * MIT license http://www.opensource.org/licenses/mit-license.php/
 * @author Lea Verou http://lea.verou.me
 */

var Prism = (function(){

// Private helper vars
var lang = /\blang(?:uage)?-(\w+)\b/i;
var uniqueId = 0;

var _ = _self.Prism = {
	util: {
		encode: function (tokens) {
			if (tokens instanceof Token) {
				return new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);
			} else if (_.util.type(tokens) === 'Array') {
				return tokens.map(_.util.encode);
			} else {
				return tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ');
			}
		},

		type: function (o) {
			return Object.prototype.toString.call(o).match(/\[object (\w+)\]/)[1];
		},

		objId: function (obj) {
			if (!obj['__id']) {
				Object.defineProperty(obj, '__id', { value: ++uniqueId });
			}
			return obj['__id'];
		},

		// Deep clone a language definition (e.g. to extend it)
		clone: function (o) {
			var type = _.util.type(o);

			switch (type) {
				case 'Object':
					var clone = {};

					for (var key in o) {
						if (o.hasOwnProperty(key)) {
							clone[key] = _.util.clone(o[key]);
						}
					}

					return clone;

				case 'Array':
					// Check for existence for IE8
					return o.map && o.map(function(v) { return _.util.clone(v); });
			}

			return o;
		}
	},

	languages: {
		extend: function (id, redef) {
			var lang = _.util.clone(_.languages[id]);

			for (var key in redef) {
				lang[key] = redef[key];
			}

			return lang;
		},

		/**
		 * Insert a token before another token in a language literal
		 * As this needs to recreate the object (we cannot actually insert before keys in object literals),
		 * we cannot just provide an object, we need anobject and a key.
		 * @param inside The key (or language id) of the parent
		 * @param before The key to insert before. If not provided, the function appends instead.
		 * @param insert Object with the key/value pairs to insert
		 * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.
		 */
		insertBefore: function (inside, before, insert, root) {
			root = root || _.languages;
			var grammar = root[inside];

			if (arguments.length == 2) {
				insert = arguments[1];

				for (var newToken in insert) {
					if (insert.hasOwnProperty(newToken)) {
						grammar[newToken] = insert[newToken];
					}
				}

				return grammar;
			}

			var ret = {};

			for (var token in grammar) {

				if (grammar.hasOwnProperty(token)) {

					if (token == before) {

						for (var newToken in insert) {

							if (insert.hasOwnProperty(newToken)) {
								ret[newToken] = insert[newToken];
							}
						}
					}

					ret[token] = grammar[token];
				}
			}

			// Update references in other language definitions
			_.languages.DFS(_.languages, function(key, value) {
				if (value === root[inside] && key != inside) {
					this[key] = ret;
				}
			});

			return root[inside] = ret;
		},

		// Traverse a language definition with Depth First Search
		DFS: function(o, callback, type, visited) {
			visited = visited || {};
			for (var i in o) {
				if (o.hasOwnProperty(i)) {
					callback.call(o, i, o[i], type || i);

					if (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, null, visited);
					}
					else if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {
						visited[_.util.objId(o[i])] = true;
						_.languages.DFS(o[i], callback, i, visited);
					}
				}
			}
		}
	},
	plugins: {},

	highlightAll: function(async, callback) {
		var env = {
			callback: callback,
			selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
		};

		_.hooks.run("before-highlightall", env);

		var elements = env.elements || document.querySelectorAll(env.selector);

		for (var i=0, element; element = elements[i++];) {
			_.highlightElement(element, async === true, env.callback);
		}
	},

	highlightElement: function(element, async, callback) {
		// Find language
		var language, grammar, parent = element;

		while (parent && !lang.test(parent.className)) {
			parent = parent.parentNode;
		}

		if (parent) {
			language = (parent.className.match(lang) || [,''])[1].toLowerCase();
			grammar = _.languages[language];
		}

		// Set language on the element, if not present
		element.className = element.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;

		// Set language on the parent, for styling
		parent = element.parentNode;

		if (/pre/i.test(parent.nodeName)) {
			parent.className = parent.className.replace(lang, '').replace(/\s+/g, ' ') + ' language-' + language;
		}

		var code = element.textContent;

		var env = {
			element: element,
			language: language,
			grammar: grammar,
			code: code
		};

		_.hooks.run('before-sanity-check', env);

		if (!env.code || !env.grammar) {
			if (env.code) {
				env.element.textContent = env.code;
			}
			_.hooks.run('complete', env);
			return;
		}

		_.hooks.run('before-highlight', env);

		if (async && _self.Worker) {
			var worker = new Worker(_.filename);

			worker.onmessage = function(evt) {
				env.highlightedCode = evt.data;

				_.hooks.run('before-insert', env);

				env.element.innerHTML = env.highlightedCode;

				callback && callback.call(env.element);
				_.hooks.run('after-highlight', env);
				_.hooks.run('complete', env);
			};

			worker.postMessage(JSON.stringify({
				language: env.language,
				code: env.code,
				immediateClose: true
			}));
		}
		else {
			env.highlightedCode = _.highlight(env.code, env.grammar, env.language);

			_.hooks.run('before-insert', env);

			env.element.innerHTML = env.highlightedCode;

			callback && callback.call(element);

			_.hooks.run('after-highlight', env);
			_.hooks.run('complete', env);
		}
	},

	highlight: function (text, grammar, language) {
		var tokens = _.tokenize(text, grammar);
		return Token.stringify(_.util.encode(tokens), language);
	},

	tokenize: function(text, grammar, language) {
		var Token = _.Token;

		var strarr = [text];

		var rest = grammar.rest;

		if (rest) {
			for (var token in rest) {
				grammar[token] = rest[token];
			}

			delete grammar.rest;
		}

		tokenloop: for (var token in grammar) {
			if(!grammar.hasOwnProperty(token) || !grammar[token]) {
				continue;
			}

			var patterns = grammar[token];
			patterns = (_.util.type(patterns) === "Array") ? patterns : [patterns];

			for (var j = 0; j < patterns.length; ++j) {
				var pattern = patterns[j],
					inside = pattern.inside,
					lookbehind = !!pattern.lookbehind,
					greedy = !!pattern.greedy,
					lookbehindLength = 0,
					alias = pattern.alias;

				if (greedy && !pattern.pattern.global) {
					// Without the global flag, lastIndex won't work
					var flags = pattern.pattern.toString().match(/[imuy]*$/)[0];
					pattern.pattern = RegExp(pattern.pattern.source, flags + "g");
				}

				pattern = pattern.pattern || pattern;

				// Don’t cache length as it changes during the loop
				for (var i=0, pos = 0; i<strarr.length; pos += strarr[i].length, ++i) {

					var str = strarr[i];

					if (strarr.length > text.length) {
						// Something went terribly wrong, ABORT, ABORT!
						break tokenloop;
					}

					if (str instanceof Token) {
						continue;
					}

					pattern.lastIndex = 0;

					var match = pattern.exec(str),
					    delNum = 1;

					// Greedy patterns can override/remove up to two previously matched tokens
					if (!match && greedy && i != strarr.length - 1) {
						pattern.lastIndex = pos;
						match = pattern.exec(text);
						if (!match) {
							break;
						}

						var from = match.index + (lookbehind ? match[1].length : 0),
						    to = match.index + match[0].length,
						    k = i,
						    p = pos;

						for (var len = strarr.length; k < len && p < to; ++k) {
							p += strarr[k].length;
							// Move the index i to the element in strarr that is closest to from
							if (from >= p) {
								++i;
								pos = p;
							}
						}

						/*
						 * If strarr[i] is a Token, then the match starts inside another Token, which is invalid
						 * If strarr[k - 1] is greedy we are in conflict with another greedy pattern
						 */
						if (strarr[i] instanceof Token || strarr[k - 1].greedy) {
							continue;
						}

						// Number of tokens to delete and replace with the new match
						delNum = k - i;
						str = text.slice(pos, p);
						match.index -= pos;
					}

					if (!match) {
						continue;
					}

					if(lookbehind) {
						lookbehindLength = match[1].length;
					}

					var from = match.index + lookbehindLength,
					    match = match[0].slice(lookbehindLength),
					    to = from + match.length,
					    before = str.slice(0, from),
					    after = str.slice(to);

					var args = [i, delNum];

					if (before) {
						args.push(before);
					}

					var wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);

					args.push(wrapped);

					if (after) {
						args.push(after);
					}

					Array.prototype.splice.apply(strarr, args);
				}
			}
		}

		return strarr;
	},

	hooks: {
		all: {},

		add: function (name, callback) {
			var hooks = _.hooks.all;

			hooks[name] = hooks[name] || [];

			hooks[name].push(callback);
		},

		run: function (name, env) {
			var callbacks = _.hooks.all[name];

			if (!callbacks || !callbacks.length) {
				return;
			}

			for (var i=0, callback; callback = callbacks[i++];) {
				callback(env);
			}
		}
	}
};

var Token = _.Token = function(type, content, alias, matchedStr, greedy) {
	this.type = type;
	this.content = content;
	this.alias = alias;
	// Copy of the full string this token was created from
	this.length = (matchedStr || "").length|0;
	this.greedy = !!greedy;
};

Token.stringify = function(o, language, parent) {
	if (typeof o == 'string') {
		return o;
	}

	if (_.util.type(o) === 'Array') {
		return o.map(function(element) {
			return Token.stringify(element, language, o);
		}).join('');
	}

	var env = {
		type: o.type,
		content: Token.stringify(o.content, language, parent),
		tag: 'span',
		classes: ['token', o.type],
		attributes: {},
		language: language,
		parent: parent
	};

	if (env.type == 'comment') {
		env.attributes['spellcheck'] = 'true';
	}

	if (o.alias) {
		var aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];
		Array.prototype.push.apply(env.classes, aliases);
	}

	_.hooks.run('wrap', env);

	var attributes = Object.keys(env.attributes).map(function(name) {
		return name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
	}).join(' ');

	return '<' + env.tag + ' class="' + env.classes.join(' ') + '"' + (attributes ? ' ' + attributes : '') + '>' + env.content + '</' + env.tag + '>';

};

if (!_self.document) {
	if (!_self.addEventListener) {
		// in Node.js
		return _self.Prism;
	}
 	// In worker
	_self.addEventListener('message', function(evt) {
		var message = JSON.parse(evt.data),
		    lang = message.language,
		    code = message.code,
		    immediateClose = message.immediateClose;

		_self.postMessage(_.highlight(code, _.languages[lang], lang));
		if (immediateClose) {
			_self.close();
		}
	}, false);

	return _self.Prism;
}

//Get current script and highlight
var script = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();

if (script) {
	_.filename = script.src;

	if (document.addEventListener && !script.hasAttribute('data-manual')) {
		if(document.readyState !== "loading") {
			if (window.requestAnimationFrame) {
				window.requestAnimationFrame(_.highlightAll);
			} else {
				window.setTimeout(_.highlightAll, 16);
			}
		}
		else {
			document.addEventListener('DOMContentLoaded', _.highlightAll);
		}
	}
}

return _self.Prism;

})();

if (typeof module !== 'undefined' && module.exports) {
	module.exports = Prism;
}

// hack for components to work correctly in node.js
if (typeof global !== 'undefined') {
	global.Prism = Prism;
}


/* **********************************************
     Begin prism-markup.js
********************************************** */

Prism.languages.markup = {
	'comment': /<!--[\w\W]*?-->/,
	'prolog': /<\?[\w\W]+?\?>/,
	'doctype': /<!DOCTYPE[\w\W]+?>/i,
	'cdata': /<!\[CDATA\[[\w\W]*?]]>/i,
	'tag': {
		pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
		inside: {
			'tag': {
				pattern: /^<\/?[^\s>\/]+/i,
				inside: {
					'punctuation': /^<\/?/,
					'namespace': /^[^\s>\/:]+:/
				}
			},
			'attr-value': {
				pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
				inside: {
					'punctuation': /[=>"']/
				}
			},
			'punctuation': /\/?>/,
			'attr-name': {
				pattern: /[^\s>\/]+/,
				inside: {
					'namespace': /^[^\s>\/:]+:/
				}
			}

		}
	},
	'entity': /&#?[\da-z]{1,8};/i
};

// Plugin to make entity title show the real entity, idea by Roman Komarov
Prism.hooks.add('wrap', function(env) {

	if (env.type === 'entity') {
		env.attributes['title'] = env.content.replace(/&amp;/, '&');
	}
});

Prism.languages.xml = Prism.languages.markup;
Prism.languages.html = Prism.languages.markup;
Prism.languages.mathml = Prism.languages.markup;
Prism.languages.svg = Prism.languages.markup;


/* **********************************************
     Begin prism-css.js
********************************************** */

Prism.languages.css = {
	'comment': /\/\*[\w\W]*?\*\//,
	'atrule': {
		pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
		inside: {
			'rule': /@[\w-]+/
			// See rest below
		}
	},
	'url': /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
	'selector': /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
	'string': {
		pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'property': /(\b|\B)[\w-]+(?=\s*:)/i,
	'important': /\B!important\b/i,
	'function': /[-a-z0-9]+(?=\()/i,
	'punctuation': /[(){};:]/
};

Prism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'style': {
			pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
			lookbehind: true,
			inside: Prism.languages.css,
			alias: 'language-css'
		}
	});
	
	Prism.languages.insertBefore('inside', 'attr-value', {
		'style-attr': {
			pattern: /\s*style=("|').*?\1/i,
			inside: {
				'attr-name': {
					pattern: /^\s*style/i,
					inside: Prism.languages.markup.tag.inside
				},
				'punctuation': /^\s*=\s*['"]|['"]\s*$/,
				'attr-value': {
					pattern: /.+/i,
					inside: Prism.languages.css
				}
			},
			alias: 'language-css'
		}
	}, Prism.languages.markup.tag);
}

/* **********************************************
     Begin prism-clike.js
********************************************** */

Prism.languages.clike = {
	'comment': [
		{
			pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
			lookbehind: true
		},
		{
			pattern: /(^|[^\\:])\/\/.*/,
			lookbehind: true
		}
	],
	'string': {
		pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: true
	},
	'class-name': {
		pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
		lookbehind: true,
		inside: {
			punctuation: /(\.|\\)/
		}
	},
	'keyword': /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
	'boolean': /\b(true|false)\b/,
	'function': /[a-z0-9_]+(?=\()/i,
	'number': /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
	'punctuation': /[{}[\];(),.:]/
};


/* **********************************************
     Begin prism-javascript.js
********************************************** */

Prism.languages.javascript = Prism.languages.extend('clike', {
	'keyword': /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
	'number': /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
	// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
	'function': /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
	'operator': /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
});

Prism.languages.insertBefore('javascript', 'keyword', {
	'regex': {
		pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
		lookbehind: true,
		greedy: true
	}
});

Prism.languages.insertBefore('javascript', 'string', {
	'template-string': {
		pattern: /`(?:\\\\|\\?[^\\])*?`/,
		greedy: true,
		inside: {
			'interpolation': {
				pattern: /\$\{[^}]+\}/,
				inside: {
					'interpolation-punctuation': {
						pattern: /^\$\{|\}$/,
						alias: 'punctuation'
					},
					rest: Prism.languages.javascript
				}
			},
			'string': /[\s\S]+/
		}
	}
});

if (Prism.languages.markup) {
	Prism.languages.insertBefore('markup', 'tag', {
		'script': {
			pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
			lookbehind: true,
			inside: Prism.languages.javascript,
			alias: 'language-javascript'
		}
	});
}

Prism.languages.js = Prism.languages.javascript;

/* **********************************************
     Begin prism-file-highlight.js
********************************************** */

(function () {
	if (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {
		return;
	}

	self.Prism.fileHighlight = function() {

		var Extensions = {
			'js': 'javascript',
			'py': 'python',
			'rb': 'ruby',
			'ps1': 'powershell',
			'psm1': 'powershell',
			'sh': 'bash',
			'bat': 'batch',
			'h': 'c',
			'tex': 'latex'
		};

		if(Array.prototype.forEach) { // Check to prevent error in IE8
			Array.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {
				var src = pre.getAttribute('data-src');

				var language, parent = pre;
				var lang = /\blang(?:uage)?-(?!\*)(\w+)\b/i;
				while (parent && !lang.test(parent.className)) {
					parent = parent.parentNode;
				}

				if (parent) {
					language = (pre.className.match(lang) || [, ''])[1];
				}

				if (!language) {
					var extension = (src.match(/\.(\w+)$/) || [, ''])[1];
					language = Extensions[extension] || extension;
				}

				var code = document.createElement('code');
				code.className = 'language-' + language;

				pre.textContent = '';

				code.textContent = 'Loading…';

				pre.appendChild(code);

				var xhr = new XMLHttpRequest();

				xhr.open('GET', src, true);

				xhr.onreadystatechange = function () {
					if (xhr.readyState == 4) {

						if (xhr.status < 400 && xhr.responseText) {
							code.textContent = xhr.responseText;

							Prism.highlightElement(code);
						}
						else if (xhr.status >= 400) {
							code.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;
						}
						else {
							code.textContent = '✖ Error: File does not exist or is empty';
						}
					}
				};

				xhr.send(null);
			});
		}

	};

	document.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);

})();
  ((window.gitter = {}).chat = {}).options = {
    room: 'uport-project/Lobby',
    activationElement: false,
    showChatByDefault: true,
    useStyles: false,
    preload: true,
    targetElement: '.gitter .content'
  };
</script><script type="text/javascript" src="https://sidecar.gitter.im/dist/sidecar.v1.js" async="async" defer="defer"></script><script type="text/javascript" src="js/script.js"></script><!DOCTYPE html><html><head><title>UPort Documentation</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"></head><body></body></html>