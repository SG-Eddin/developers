.guides
  .pagewrap
    .sidebar
    .content
      .guide
        section
          :markdown-it
            # Getting Started

            Welcome to the uPort usage guide!

            Here we will walk you through all the necessary steps to get up and running with your first dapp.

            Web 3.0 and decentralized applications _require a fundamental rethinking_ of the moving parts of the web so it is important to read everything or you may miss some important elements around the design decisions of what you are working with.

            **Also please note**: these libraries are in progress and are subject to change. Gitter is a great place for the community to congregate and help each other. Lets get started.

            ## Download the Mobile App

            Firstly, we will download the uPort mobile app.

            The mobile app is where your [ECDSA private keys](https://blog.cloudflare.com/ecdsa-the-digital-signature-algorithm-of-a-better-internet/) are held (inside the secure enclave that's unlocked with your fingerprint). These keys are what controls the administrative layer between your device and the blockchain.

            You will also have locally stored data in the app that is relevant to you such as your contacts and verified credentials. Essentially, the phone is an extension of you, and uPort is your internet native passport to the secure, decentralized web.

            You can download the mobile app with one of the links below.

            [uPort iOS](http://itunes.apple.com) | [uPort iOS](http://play.google.com)

            Once you have downloaded the app, go ahead and create an identity. This identity will be resident on the `RINKEBY` Ethereum test network. You can create more identities on the same netowrk or on other Ethereum networks (`ROPSTEN` and `KOVAN`) in the settings menu so you can test counterparty interactions on the **same network**.

            ## Register your App

            Next we shall regsiter an application on the blockchain.

            When a users interacts with an app, they will desire to see relevant information, a picture, and any other helpful indicators on their transacation cards that this is the correct endpoint they wish to interact with. This registration process will create an identity for your app so that this becomes possible, and for your frontend to know where to listen to changes on the blockchain.

            Let's go create an app over at the [uPort App Manager](appmanager.uport.me).

            **Make sure to save the signing key somewhere secure! This will not be stored in browser for you for security reasons**.

            ## Install the Library/SDK

            We now have the mobile uPort app and a registered application. Let's install the library in our project.

            **Please make sure you have Node.Js and NPM installed**

            uPort and its depending libraries are dependent on the Node.Js ecosystem.

            _Native (iOS & Android) Application libraries are in the works._

            Go to your Terminal and `cd` to your project folder.

            ```bash
            npm install --save uport-connect
            ```

            ## Add your Keys

            Now that we have the needed dependency, lets go grab our keys from the app manager.

            **You may copy the code with the injected keys in the accordion at the bottom of your created app's page to help you get started quickly or you can follow the directions below.**

            We need to instantiate the uPort object with an app's identity.

            Lets create an object from the `Connect` function and feed in the App's name, id, and signing key.

            ```js
            const uport = new Connect('NAME_OF_DAPP', {
              clientId: 'CLIENT_ID',
              signer: SimpleSigner('SIGNING KEY')
            })
            ```

            The clientID is the public address of your app and the signer (wrapped with the SimpleSigner function) is the signing key of your app that you will help create JWT tokens. These bits of information are given to you after registering an application.

            **We should also export the `web3` object from the resulting uport object for signing transactions later.**

            ```js
            const web3 = uport.getWeb3()
            export { web3, uport }
            ```            
        section
          :markdown-it
            # Requesting Credentials

              The first and most basic step you should take is to allow your user to connect their uPort to your app. The `requestCredentials` method is how you accomplish this, similar in concept to logging in , except there is no server session for you to manage. All you need to do to "connect" is to disclose the requested credentials you have in your uPort identity.

            ## Calling the request method

            **By default** the `uport-connect` library will fire a QR image inside of an injected global modal to help you get up and running quickly.

            **This can be disabled** by intercepting the URI so you may use another library to customize the look and feel of the QR image. See [Custom QR Styling](#custom-qr-styling)

            Once the user has scanned the displayed QR image, and has submitted their credentials, the promise should resolve with a Schema.org person JSON data payload. You can then handle this data however you desire in the then function.

            ```js
            // Basic usage with modal injection
            uport.requestCredentials()
                 .then((credentials) => {
                   // Do something after they have disclosed credentials
            })
            ```

            The expected payload should look like:

            ```js
            {
              "@context":"http://schema.org",
              "@type":"Person",
              "name":"Agent Smith",
              "address":"23fga3r2hh87ddhq98dhas8dh101j9f449w0",
              "network":"ropsten",
              "publicKey":"0x04016751595cf2f1429367d6c83a826526g613b4f7574af55ded0364f0fb34600bceba9211e5864ae616d7e83b5e3c79f1c913b40c8d38c64952fef383fd3ad637",
              "image":{
                "@type":"ImageObject",
                "name":"avatar",
                "contentUrl":"/ipfs/QmeXP3C3S95zV9Wj9e2VTq9Z3CCCNoqksJrM5VQYJx2yM9"
              }
            }
            ```

            ## Requesting specific credentials

            You can request specific credentials by submitting an array of values in an array of the `requested` key of a passed object.

            ```js
            uport.requestCredentials({
              requested: ['name', 'phone', 'country'],
              }).then((credentials) => {
                // Do something after they have disclosed credentials
            })
            ```

            ## Enabling Push Notifications

            When a transaction is going to be signed, if the `notifications` flag is set to `true` **it will allow any future transaction signing to fire a prompt in the uPort mobile app.** For UX considerations, we encourage developers to use this, otherwise your users will have to scan a QR code per each interaction.

            ```js
            uport.requestCredentials({
              requested: ['name', 'phone', 'country'],
              notifcations: true
              }).then((credentials) => {
                // Do something after they have disclosed credentials
            })
            ```

            ## Custom QR Styling (web)

            We have had success with the [KJUA QR Library](https://larsjung.de/kjua/). It's also recommended you wrap the QR or create a seperate button for mobile.

            ```js
            uport.requestCredentials({
              requested: ['name', 'phone', 'country'],
              notifcations: true,
              (uri) => {

                const qr = kjua({
                  text: uri,
                  fill: '#000000',
                  size: 400,
                  back: 'rgba(255,255,255,1)'
                })

                // Create wrapping link for mobile touch
                let aTag = document.createElement('a')
                aTag.href = uri

                // Nest QR in <a> and inject
                aTag.appendChild(qr)
                document.querySelector('#kqr').appendChild(aTag)
              }
              }).then((credentials) => {
                // Do something after they have disclosed credentials
            })
            ```

            ## Logging in via Mobile (sdk)

            **Under construction**

            ## Playground

          iframe(style="width:100%; max-width:95%; height: 800px" src="https://www.webpackbin.com/bins/-Kq-LKec34MlPK9_UMVr")

        section
          :markdown-it
            # Attesting Credentials

            One of the core needs of Web 3.0 is to build trust in a self-sovereign world. We establish facts which are not mathematically derived by social consensus. To create social consensus, actors must attest to things being true. We can do this with uPort using the `uport.attestCredentials` function.

            **NOTE:** Currently only one credential can be pushed at a time. We are working to fix this soon.

            ## Calling the attest method

             ```js
             uport.attestCredentials({
               sub: 'THE_RECEIVING_UPORT_ID',
               claim: { CUSTOM_PROPERTY: PROPERTY_VALUE },
             })
             ```

            ## Setting an expiration date

            ```js
            uport.attestCredentials({
              sub: 'THE_RECEIVING_UPORT_ID',
              claim: { CUSTOM_PROPERTY: PROPERTY_VALUE },
              exp: new Date().getTime() + 30 * 24 * 60 * 60 * 1000,  // Optional expiration
            })
            ```

            ## Attesting multiple credentials

            **Under construction**

        section
          :markdown-it
            # Signing Transactions

            uPort comes pre-baked with a web3 instance that calls to [Infura](https://github.com/ethereumjs/testrpc), our p2p swarm of nodes we have built to make your life easy. All you need to do is grab our `web3` object and instantiate a smart contract javascript object with a **provided ABI**.

            ## Supply the contract ABI

            An ABI (Application BINARY Interface) can be generated by compiling your smart contract with the [Remix](https://ethereum.github.io/browser-solidity/) Web IDE. Its on the "Contracts" tab down where it says `interface`. You can deploy this contract to the chain with the **Web3** deploy code just below that in your local Ethereum node console or with our build & deploy tool called [Truffle](http://truffleframework.com/).

             ```js
             function MyContractSetup () {
               let MyContractABI = web3.eth.contract(PROVIDED_CONTRACT_ABI)
               let MyContractObj = MyContractABI.at(DEPLOYED_CONTRACT_ADDRESS_LOCATION)
               return MyContractObj
             }
             const MyContract = MyContractSetup()
             ```

            ## Create the contract object

            In a typical application, upon load, there is data usually being requested by a server to get the current state of the user's data. We must do the same here, but rather than reading a SQL database, we are instead reading the blockchain.

            At ConsenSys we use our Web 3.0 infrastructure stack called [Infura](https://github.com/uport-project/demo/blob/master/infura.io) to make the amount of possible calls scalable. You could otherwise have an Ethereum node local on your machine with a downloaded copy of the blockchain you could query. Calls can be simulated without having a copy of the blockchain though using a local [TestRPC](https://github.com/ethereumjs/testrpc) node, but thats out of scope for this guide.

             ```js
             // Basic call to get some return data, no transaction signing
             MyContract.someMethod.call(METHOD_INPUT_DATA, (error, response) => {
               if (error) { throw error }
               console.log(response)
             })
             ```

            ## Call a method on the contract

            Calling a method on a smart contract is essentially no different than that of a javascript function, except that solidity contracts cannot handle JSON objects, only strings and numbers.

             ```js
             // Transaction signing (that will fire a QR to scan or card in the mobile app)
             MyContract.someMethod(METHOD_INPUT_DATA, (error, txHash) => {
               if (error) { throw error }
                 waitForMined(txHash, { blockNumber: null }, // see next area
                 function pendingCB () {
                   // Signal to the user you're still waiting
                   // for a block confirmation
                 },
                 function successCB (data) {
                   // Great Success!
                   // Likely you'll call some eventPublisherMethod(txHash, data)
                 }
               )
             })
            ```

            ## Wait for mining to complete

            When a transaction is signed and submitted to a smart contract, the Ethereum network takes time to mine (confirm) the transaction (typically 15 seconds). During this time we will need to poll the Web3 node (aka provider and in our case, its Infura), to see if its been mined. We will keep checking it with a function called `waitForMined` and have a pending callback and a success callback to manage state.

            ```js
            // Callback handler for whether it was mined or not
            const waitForMined = (txHash, response, pendingCB, successCB) => {
              if (response.blockNumber) {
                successCB()
              } else {
                pendingCB()
                  pollingLoop(txHash, response, pendingCB, successCB)
              }
            }

            // Recursive polling to do continuous checks for when the transaction was mined
            const pollingLoop = (txHash, response, pendingCB, successCB) => {
              setTimeout(function () {
                web3.eth.getTransaction(txHash, (error, response) => {
                  if (error) { throw error }
                    if (response === null) {
                      response = { blockNumber: null }
                    } // Some ETH nodes do not return pending tx
                    waitForMined(txHash, response, pendingCB, successCB)
                })
              }, 1000) // check again in one sec.
            }
            ```
      section.guide
      section.guide
