//- include ../../mixins/iframeloader

section
  :markdown-it
    # Signing Transactions

    uPort comes pre-baked with a web3 instance that calls to [Infura](https://github.com/ethereumjs/testrpc), our p2p swarm of nodes we have built so you don't need to stand up your own. All you need to do is grab our `web3` object and instantiate a smart contract javascript object with a **provided ABI**.

    ## Supply the contract ABI

    An ABI (Application BINARY Interface) can be generated by compiling your smart contract with the [Remix](https://ethereum.github.io/browser-solidity/) Web IDE. Its on the "Contracts" tab down where it says `interface`. You can deploy this contract to the chain with the **Web3** deploy code just below that in your local Ethereum node console or with our build & deploy tool called [Truffle](http://truffleframework.com/).
    
    ## Create the contract object

     ```js
     function MyContractSetup () {
       let MyContractABI = web3.eth.contract(PROVIDED_CONTRACT_ABI)
       let MyContractObj = MyContractABI.at(DEPLOYED_CONTRACT_ADDRESS_LOCATION)
       return MyContractObj
     }
     const MyContract = MyContractSetup()
     ```

    ## Call a basic method on the contract

    In a typical application, upon load, there is data usually being requested by a server to get the current state of the user's data. We must do the same here, but rather than reading a SQL database, we are instead reading the blockchain.

    At ConsenSys we use our Web 3.0 infrastructure stack called [Infura](https://github.com/uport-project/demo/blob/master/infura.io) to make the amount of possible calls scalable. You could otherwise have an Ethereum node local on your machine with a downloaded copy of the blockchain you could query. Calls can be simulated without having a copy of the blockchain though using a local [TestRPC](https://github.com/ethereumjs/testrpc) node, but thats out of scope for this guide.
    
    

     ```js
     // Basic call to get some return data, no transaction signing
     MyContract.someMethod.call(METHOD_INPUT_DATA, (error, response) => {
       if (error) { throw error }
       console.log(response)
     })
     ```

    ## Call a tx signing method on the contract

    Calling a method on a smart contract is essentially no different than that of a javascript function, except that solidity contracts cannot handle JSON objects, only strings and numbers.

     ```js
     // Transaction signing (that will fire a QR to scan or card in the mobile app)
     MyContract.someMethod(METHOD_INPUT_DATA, (error, txHash) => {
       if (error) { throw error }
         waitForMined(txHash, { blockNumber: null }, // see next area
         function pendingCB () {
           // Signal to the user you're still waiting
           // for a block confirmation
         },
         function successCB (data) {
           // Great Success!
           // Likely you'll call some eventPublisherMethod(txHash, data)
         }
       )
     })
    ```

    ## Wait for mining to complete

    When a transaction is signed and submitted to a smart contract, the Ethereum network takes time to mine (confirm) the transaction (typically 15 seconds). During this time we will need to poll the Web3 node (aka provider and in our case, its Infura), to see if its been mined. We will keep checking it with a function called `waitForMined` and have a pending callback and a success callback to manage state.

    ```js
    // Callback handler for whether it was mined or not
    const waitForMined = (txHash, response, pendingCB, successCB) => {
      if (response.blockNumber) {
        successCB()
      } else {
        pendingCB()
          pollingLoop(txHash, response, pendingCB, successCB)
      }
    }

    // Recursive polling to do continuous checks for when the transaction was mined
    const pollingLoop = (txHash, response, pendingCB, successCB) => {
      setTimeout(function () {
        web3.eth.getTransaction(txHash, (error, response) => {
          if (error) { throw error }
            if (response === null) {
              response = { blockNumber: null }
            } // Some ETH nodes do not return pending tx
            waitForMined(txHash, response, pendingCB, successCB)
        })
      }, 1000) // check again in one sec.
    }
    ```
    
    ## ST Playground
    
  +iframe('stIframeInject')
